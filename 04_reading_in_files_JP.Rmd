---
title: "Reading_in_files"
author: "JR"
date: "6/24/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(GenomicRanges)
library(rtracklayer)
library(tidyverse)
library(ggpubr)
library(Gviz)
source("util/_setup.R")
source("util/intersect_functions.R")
source("util/plotting_functions.R")
```

Here we *are going* to learn how to read in files and things to consider.
We will start with a .csv file that shows how many times a protein is bound to
DNA (promoters specifically) it seems scary but we will walk through it slowly.

First we need to learn how to install packages. We will discuss the source functions
at a later time, but have them set up in students directory where we will be 
working together.

```{r}
?install.packages
install.packages("tidyverse")
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager", version = '3.10')
# 
# BiocManager::install("GenomicRanges")
```

Now try installing the packages listed above. Just paste in the name above into 
the install packages R function. Some packages like GenomicRanges are from Bioconductor and those will
need to be installed with the BiocManager::install function.

One typically starts by importing a list of R packages that will be used. These are many of packages we will use and explain in later classes. For now we just want to gain some fundemental R programming skills.

The source calls below the library calls are the file path to functions we will
code or use later in class. For now we will just focus on the fundemental coding
while introducing the packages and functions as they come into play.

Once the libraries are loaded you have official run an R program :)

Now let's use an example data file we will produce and how we can use R to do
some quick analyses (e.g. how much space do exons take in the human genome?).


Let's get started reading in a file "../../data/number_of_peaks_per_dbp.csv".

SKIP if in class -- data folder is already in (scratch/Shares/rinnclass/data)
***
All the files needed for this exeRcise can be downloaded here https://www.dropbox.com/sh/76etjxl10v2hcuc/AAAIk9a6aMhw8CvUtKlFnMn6a?dl=0
(note the gencode annotation file is large). 

or copy this directory to your folder

cp -r data /scratch/Shares/rinnclass/<dir name>


On youtube download these files into a directory in your working directory called "data"

https://www.dropbox.com/sh/76etjxl10v2hcuc/AAAIk9a6aMhw8CvUtKlFnMn6a?dl=0

Please make a directory called data and place the files
there to keep file paths consistent. 
***


```{r}
# lets read in the bed using read_csv or read.csv (but it is slower)
peaks_per_dbp <- read_csv("../../data/number_of_peaks_per_dbp.csv")

# Now we have an object in the environment that is called peaks_per_dbp -- click to look!
# or we can take a peak with head
head(peaks_per_dbp)


# This is a tibble or data frame object you can think of like excel sheet for now
# More on Tibble here:
# https://tibble.tidyverse.org/
# Cool we see the gene name, number of times it bound to a gene promoter adn
# the length of the peak. We see that gene name is in character, and the others
# in "num" which means they are numeric-with floating points

# Let's get more infomration about these peaks
table(peaks_per_dbp$dbp)
# Not very useful in this case because there is only one entry for each DBP

summary(peaks_per_dbp$num_peaks)
# Ok this is super helpful - we see the quartiles for each of the catagories
# except the gene name. This is filtered to proteins with more than 250 peaks
# so we see the minimum is 263 peaks, and max is 60,035! These are very helpful
# bits of information.



```

# Now let's do some investigation to see which of these genes has the largest
# or smallest number of peaks

```{r}
## Filter is a great way to quickly scan for specific gene properties
#### Filter basic context is: filter(data, filter logic)
#### Let's find the gene with most peaks using filter
summary(peaks_per_dbp$num_peaks)
?filter
peaks_per_dbp$num_peaks > 60000

max_peaks <- dplyr::filter(peaks_per_dbp, num_peaks > 30000, total_peak_length == 133310967)
```

#### Here we find the gene with the most peaks is eGFP-CEBPB 
#### The $ sign is an "indexing" symbol that means go to the column of "file" 
#### Termed num_peaks (these also tab deliminate if it's going well)

#### Finding the gene with the fewest peaks

```{r}
min_peaks <- filter(peaks_per_dbp, num_peaks < 264)
```

#### Here we find the gene with least peaks is ZNF639

### Let's find the number of peaks for a specific gene say POLR2A
```{r}
gene_pol2 <- filter(peaks_per_dbp, dbp == "POLR2A")
```

#### Voila we have just the info for your favorite gene.

### Now let's make a new column in the file table
```{r}
peaks_per_dbp$newcol <- "What?"
peaks_per_dbp$id <- 1:nrow(peaks_per_dbp)
```

#### Now we have a newcol with the character "What?" in it.
#### That isn't very useful and later we can see how to merge in new data so 
#### it is linked with the gene name

#### So let's remove that column

```{r}
# Basic indexing syntax
# More on R indexing https://stats.idre.ucla.edu/r/modules/subsetting-data/
peaks_per_dbp[1:5, 1]

peaks_per_dbp <- peaks_per_dbp[,-4]
```

#### This indexed into the 4th column and the - sign removed that column
#### We can use this simple approach to add and subtract columns we will see
#### other ways as we advance.

### Now let's make a plot of the data. 
#### First a histogram of number of peaks for each DBP

```{r}
?hist
hist(peaks_per_dbp$num_peaks, breaks = 40)
```

#### This shows the distribution of peaks for each DBP as we saw above.
##### the breaks allows you to determine how fine you want the data (num bins)

#### Now let's plot the number of peaks versus peak width.

```{r}
plot(x = peaks_per_dbp$num_peaks, y = peaks_per_dbp$total_peak_length)
```
#### We can see a linear relationship, as expected that a DBP that has more peaks
#### will have more base pairs covered.



Now let's dig into the data file to subset it into the genes we are interested in.

```{r}
### First let's make a list of genes we want. 
# To make a vector of characters we use the c() function
genes <- c("POLR2A","POLR2B", "SUPT5H")
```

### So our first argument is to filter file, then we call grepl to match the terms
### grepl is called then the genes above are called and collapsed by |
### This collapse is making the names in to a regexp (very cool and more later)
### Then where we want to search in peaks_per_dbp$dbp index. 

### In other words: grepl is searching for the regex of genes as input into $dbp
### grep is making a list of terms to filter the file.
### First let's see if we searched by the character names of these genes

It's worth noting that things can be accomplished in many different ways in R.
Here we'll get to the same subset of row entries two different ways. 

```{r}
# First we'll use grep to demonstrate how multiple character 
# strings can be searched at once. And how you can 
# index the rows (or colunms) of a data.frame using a logical vector
# Grepl will give us a logical vector instead of the index of the matching characters.
?grepl
pattern_to_search <- paste0(genes, collapse = "|")
table(grepl(pattern_to_search, peaks_per_dbp$dbp))
ppdbp_subset <- peaks_per_dbp[grepl(pattern_to_search, peaks_per_dbp$dbp),]
peaks_per_dbp[1:3, 1:2]
# index [] asks for two dimennsions, denoted by commas between each dimmension - like rows, columns in a csv
# Another way we can do this is with filter as we saw before
# Here we're introducing also the %in% command -- which is quite useful.
peaks_per_dbp$dbp %in% genes
ppdbp_subset <- dplyr::filter(peaks_per_dbp, dbp %in% genes)

# Finally one last way that we can achieve the same thing is
# by setting row names (we already have column names) and
# indexing directly by using the name of the DBP.
# %>% is a pipe command, takes whatever is on the right, and pipes in into what is on the left, in this case wetake the column to rownames and pipe it insto the peaks per dbp
#the below syntax is the same as column_to_rownames(peaks_per_dbp, var - "dbp")

peaks_per_dbp <- peaks_per_dbp %>%
  column_to_rownames(var = "dbp")
# What this all did was remove the row name that was just numbers, and replace it with the first column, in this case the dbp
# Now we can index using the names of the genes intead of the number corresponding to each row.
peaks_per_dbp["POLR2A", "total_peak_length"]
ppdbp_subset <- peaks_per_dbp[genes,]
```

# In addition to editing columns by indexing with the dollar sign
# you can change a column the tidyverse way by using the mutate function.

```{r}
### Let's take a look at the data.frame real quick
### The total peak length is quite long, let's make it in Millions
### NOTE: PIPE "%>%"
# The pipe will put evaluate first what's on the left hand side of the pipe
# and place it as the first argument of the function on the right hand side.
peaks_per_dbp <- peaks_per_dbp %>%
  mutate(tpl_m = total_peak_length / 1000000)
### Cool now we have a new column that is much easier to read for total length.

### Lets see if we can write over the previous column instead of removing it
### we can just set the new col to the old col name
peaks_per_dbp <- peaks_per_dbp %>% 
  mutate(total_peak_length = total_peak_length / 1000000) 
head(peaks_per_dbp)
### Sweet we can mutate and just overide columns -- but we can also perform a FUN!
### NOTE IFELSE! A NESTED IFELSE at that!!
### Let's give it a go:
hist(peaks_per_dbp$tpl_m)
peaks_per_dbp <- peaks_per_dbp %>% 
  mutate(peak_genome_coverage = ifelse(tpl_m < 10, "small",
                          ifelse(total_peak_length < 60, "medium", "large")))


### Very nice we can see we have three categories of legnths now. This is common
### to want to take a continious variable such as gene expression levels and
### define them as "categorical" or high medium low. 
### Let's take a look
table(peaks_per_dbp$peak_genome_coverage)

# R represents categorical variables with factors (which represent each unique character
# as a number under the hood). This makes it possible to run regressions and plot
# character data. We'll get more practice with factors later. One thing to note now
# is that categories that have a natural ordering to them like small, med, large
# can be properly ordered with the levels parameter. They will be represented by 
# 1, 2, and 3 respectively. Without the levels argument, the factor levels would be 
# in alphanumeric ordering.
peaks_per_dbp <- peaks_per_dbp %>%
  mutate(peak_genome_coverage = factor(peak_genome_coverage, levels = c("small", "medium", "large")))

head(as.character(peaks_per_dbp$peak_genome_coverage))
head(as.numeric(peaks_per_dbp$peak_genome_coverage))
table(as.numeric(peaks_per_dbp$peak_genome_coverage))

plot(peaks_per_dbp$peak_genome_coverage, peaks_per_dbp$num_peaks)

# Notice that the plot function is pretty sophisticated. It figured out that 
# we have a factor variable with a numeric y-axis and decided to make a box and whisker plot.

# What if we wanted not just to plot this, but find out the average total_peak_length
# by category? R is really made for these types of questions and we'll learn how 
# to do this type of thing in upcoming classes.
```

END Lesson
